var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import React, { useEffect, useRef, useState } from 'react';
import { createPortal } from 'react-dom';
import createCache from '@emotion/cache';
import { CacheProvider } from '@emotion/react';
import { useDialogContext, useDialogDispatch, } from './TranslationDialogContextProvider';
export var NewWindow = function (props) {
    var newWindow = useRef(null);
    var _a = __read(useState(null), 2), popup = _a[0], setPopup = _a[1];
    var dispatch = useDialogDispatch();
    var container = useDialogContext(function (c) { return c.container; });
    var setContainer = function (el) {
        dispatch({ type: 'SET_CONTAINER', payload: el });
    };
    var onClose = function () {
        dispatch({ type: 'ON_CLOSE' });
    };
    useEffect(function () {
        // Create container element on client-side
        var div = document.createElement('div');
        div.style.width = '100vw';
        div.style.height = '100vh';
        div.style.position = 'relative';
        setContainer(div);
    }, []);
    useEffect(function () {
        // When container is ready
        if (container) {
            // Create window
            var win_1 = window.open('', '', 'width=600,height=600,left=200,top=200');
            win_1.document.title = 'Tolgee - Translate Text';
            if (!win_1.document) {
                alert('Please allow popups to open new window.');
            }
            newWindow.current = win_1;
            // Append container
            win_1.document.body.style.margin = '0px';
            win_1.document.body.appendChild(container);
            var onExit_1 = function () {
                setContainer(null);
                win_1.close();
                onClose();
            };
            win_1.onbeforeunload = function () {
                setContainer(null);
                onClose();
            };
            var onKeyDown_1 = function (e) {
                if (e.key === 'Escape') {
                    dispatch({ type: 'ON_CLOSE' });
                }
            };
            var onBeforeUnload_1 = function () {
                onExit_1();
            };
            win_1.document.addEventListener('keydown', onKeyDown_1, true);
            window.addEventListener('beforeunload', onBeforeUnload_1, true);
            setPopup(win_1);
            return function () {
                win_1.document.removeEventListener('keydown', onKeyDown_1, true);
                window.removeEventListener('beforeunload', onBeforeUnload_1, true);
                setContainer(null);
                newWindow.current.close();
                setPopup(null);
            };
        }
    }, [container]);
    useEffect(function () {
        popup === null || popup === void 0 ? void 0 : popup.focus();
    });
    var styleCache = React.useMemo(function () {
        // styles insertion point in popup head
        var head = popup === null || popup === void 0 ? void 0 : popup.document.head;
        return createCache({
            key: 'external',
            container: head,
        });
    }, [popup]);
    return container
        ? createPortal(React.createElement(CacheProvider, { value: styleCache }, props.children), container)
        : null;
};
//# sourceMappingURL=NewWindow.js.map